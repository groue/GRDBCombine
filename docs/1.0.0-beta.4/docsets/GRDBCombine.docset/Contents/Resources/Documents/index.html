<!DOCTYPE html>
<html lang="en">
  <head>
    <title>GRDBCombine  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="GRDBCombine  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">GRDBCombine 1.0.0-beta.4 Docs</a> (100% documented)</p>
        <p class="header-right"><a href="https://github.com/groue/GRDBCombine"><img src="img/gh.png"/>View on GitHub</a></p>
        <p class="header-right"><a href="dash-feed://https%3A%2F%2Fgroue.github.io%2FGRDBCombine%2Fdocs%2F1.0.0-beta.4%2Fdocsets%2FGRDBCombine.xml"><img src="img/dash.png"/>Install in Dash</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">GRDBCombine Reference</a>
        <img id="carat" src="img/carat.png" />
        GRDBCombine  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/DatabasePublishers.html">DatabasePublishers</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/DatabasePublishers/Read.html">– Read</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/DatabasePublishers/DatabaseRegion.html">– DatabaseRegion</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/DatabasePublishers/Write.html">– Write</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/DatabasePublishers/Value.html">– Value</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/DatabaseReader.html">DatabaseReader</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/DatabaseRegionObservation.html">DatabaseRegionObservation</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/DatabaseWriter.html">DatabaseWriter</a>
              </li>
              <li class="nav-group-task">
                <a href="Extensions/ValueObservation.html">ValueObservation</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h1 id='grdbcombine' class='heading'>GRDBCombine</h1>

<p><a href="https://developer.apple.com/swift/"><img alt="Swift 5.2" src="https://img.shields.io/badge/swift-5.2-orange.svg?style=flat"></a>
<a href="https://developer.apple.com/swift/"><img alt="Platforms" src="https://img.shields.io/cocoapods/p/GRDBCombine.svg"></a>
<a href="https://github.com/groue/GRDBCombine/blob/master/LICENSE"><img alt="License" src="https://img.shields.io/github/license/groue/GRDBCombine.svg?maxAge=2592000"></a></p>
<h3 id='a-set-of-extensions-for-a-href-http-sqlite-org-sqlite-a-a-href-https-github-com-groue-grdb-swift-grdb-swift-a-and-a-href-https-developer-apple-com-documentation-combine-combine-a' class='heading'>A set of extensions for <a href="http://sqlite.org">SQLite</a>, <a href="https://github.com/groue/GRDB.swift">GRDB.swift</a>, and <a href="https://developer.apple.com/documentation/combine">Combine</a></h3>

<hr>

<p><strong>Latest release</strong>: June 26, 2020 • version 1.0.0-beta.4 • <a href="CHANGELOG.md">Release Notes</a> • <a href="Documentation/GRDBCombine1MigrationGuide.md">Migrating From GRDBCombine 0.x to GRDBCombine 1.0</a></p>

<p><strong>Requirements</strong>: iOS 13.0+ / macOS 10.15+ / tvOS 13.0+ / watchOS 6.0+ &bull; Swift 5.2+ / Xcode 11.4+</p>

<table><thead>
<tr>
<th>Swift version</th>
<th>GRDBCombine version</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Swift 5.2</strong></td>
<td><strong>v1.0.0-beta.4</strong>, <a href="https://github.com/groue/GRDBCombine/tree/v0.8.1">v0.8.1</a></td>
</tr>
<tr>
<td>Swift 5.1</td>
<td><a href="https://github.com/groue/GRDBCombine/tree/v0.8.1">v0.8.1</a></td>
</tr>
</tbody></table>

<p><strong>Contact</strong>: Report bugs and ask questions in <a href="https://github.com/groue/GRDBCombine/issues">Github issues</a>.</p>

<hr>
<h2 id='usage' class='heading'>Usage</h2>

<p>To connect to the database, please refer to <a href="https://github.com/groue/GRDB.swift">GRDB</a>, the database library that supports GRDBCombine.</p>

<details>
  <summary><strong>Asynchronously read from the database</strong></summary>
  
This publisher reads a single value and delivers it.

&ldquo;`swift
// DatabasePublishers.Read<[Player]>
let players = dbQueue.readPublisher { db in
    try Player.fetchAll(db)
}
&rdquo;`

</details>

<details>
  <summary><strong>Asynchronously write in the database</strong></summary>
  
This publisher updates the database and delivers a single value.

&ldquo;`swift
// DatabasePublishers.Write<Void>
let write = dbQueue.writePublisher { db in
    try Player(&hellip;).insert(db)
}

// DatabasePublishers.Write<Int>
let newPlayerCount = dbQueue.writePublisher { db -> Int in
    try Player(&hellip;).insert(db)
    return try Player.fetchCount(db)
}
&rdquo;`

</details>

<details>
  <summary><strong>Observe changes in database values</strong></summary>

This publisher delivers fresh values whenever the database changes:

&ldquo;`swift
// A publisher with output [Player] and failure Error
let publisher = ValueObservation
    .tracking { db in try Player.fetchAll(db) }
    .publisher(in: dbQueue)

// A publisher with output Int? and failure Error
let publisher = ValueObservation
    .tracking { db in try Int.fetchOne(db, sql: &quot;SELECT MAX(score) FROM player&rdquo;) }
    .publisher(in: dbQueue)
&ldquo;`

</details>

<details>
  <summary><strong>Observe database transactions</strong></summary>

This publisher delivers database connections whenever a database transaction has impacted an observed region:

&rdquo;`swift
// A publisher with output Database and failure Error
let publisher = DatabaseRegionObservation
    .tracking(Player.all())
    .publisher(in: dbQueue)

let cancellable = publisher.sink(
    receiveCompletion: { completion in &hellip; },
    receiveValue: { (db: Database) in
        print(&ldquo;Exclusive write access to the database after players have been impacted&rdquo;)
    })

// A publisher with output Database and failure Error
let publisher = DatabaseRegionObservation
    .tracking(SQLRequest<Int>(sql: &ldquo;SELECT MAX(score) FROM player&rdquo;))
    .publisher(in: dbQueue)

let cancellable = publisher.sink(
    receiveCompletion: { completion in &hellip; },
    receiveValue: { (db: Database) in
        print(&ldquo;Exclusive write access to the database after maximum score has been impacted&rdquo;)
    })
&ldquo;`

</details>
<h1 id='documentation' class='heading'>Documentation</h1>

<ul>
<li><a href="https://groue.github.io/GRDBCombine/docs/1.0.0-beta.4/index.html">Reference</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="Documentation/Demo/README.md">Demo Application</a></li>
<li><a href="#asynchronous-database-access">Asynchronous Database Access</a></li>
<li><a href="#database-observation">Database Observation</a></li>
</ul>
<h2 id='installation' class='heading'>Installation</h2>

<p>To use GRDBCombine with the <a href="https://swift.org/package-manager/">Swift Package Manager</a>, add a dependency to your <code>Package.swift</code> file:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">package</span> <span class="o">=</span> <span class="kt">Package</span><span class="p">(</span>
    <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">package</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="s">"https://github.com/groue/GRDBCombine.git"</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
</code></pre>

<p>To use GRDBCombine with <a href="http://cocoapods.org/">CocoaPods</a>, specify in your <code>Podfile</code>:</p>
<pre class="highlight ruby"><code><span class="n">pod</span> <span class="s1">'GRDBCombine'</span>
</code></pre>

<p>To use GRDBCombine with <a href="https://www.zetetic.net/sqlcipher/">SQLCipher</a>, use <a href="http://cocoapods.org/">CocoaPods</a>, and specify in your <code>Podfile</code>:</p>
<pre class="highlight ruby"><code><span class="n">pod</span> <span class="s1">'GRDBCombine/SQLCipher'</span>
</code></pre>
<h1 id='asynchronous-database-access' class='heading'>Asynchronous Database Access</h1>

<p>GRDBCombine provide publishers that perform asynchronous database accesses.</p>

<ul>
<li><a href="#databasereaderreadpublisherreceiveonvalue"><code>readPublisher(receiveOn:value:)</code></a></li>
<li><a href="#databasewriterwritepublisherreceiveonupdates"><code>writePublisher(receiveOn:updates:)</code></a></li>
<li><a href="#databasewriterwritepublisherreceiveonupdatesthenread"><code>writePublisher(receiveOn:updates:thenRead:)</code></a></li>
</ul>
<h4 id='code-databasereader-readpublisher-receiveon-value-code' class='heading'><code><a href="Extensions/DatabaseReader.html#/s:4GRDB14DatabaseReaderP11GRDBCombineE13readPublisher9receiveOn5valueAD0B10PublishersO4ReadVy_qd_0_Gqd___qd_0_AA0B0CKct7Combine9SchedulerRd__r0_lF">DatabaseReader.readPublisher(receiveOn:value:)</a></code></h4>

<p>This methods returns a publisher that completes after database values have been asynchronously fetched.</p>
<pre class="highlight swift"><code><span class="c1">// DatabasePublishers.Read&lt;[Player]&gt;</span>
<span class="k">let</span> <span class="nv">players</span> <span class="o">=</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">readPublisher</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchAll</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>Any attempt at modifying the database completes subscriptions with an error.</p>

<p>When you use a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-queues">database queue</a> or a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-snapshots">database snapshot</a>, the read has to wait for any eventual concurrent database access performed by this queue or snapshot to complete.</p>

<p>When you use a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-pools">database pool</a>, reads are generally non-blocking, unless the maximum number of concurrent reads has been reached. In this case, a read has to wait for another read to complete. That maximum number can be <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#databasepool-configuration">configured</a>.</p>

<p>This publisher can be subscribed from any thread. A new database access starts on every subscription.</p>

<p>The fetched value is published on the main queue, unless you provide a specific scheduler to the <code>receiveOn</code> argument.</p>
<h4 id='code-databasewriter-writepublisher-receiveon-updates-code' class='heading'><code><a href="Extensions/DatabaseWriter.html#/s:4GRDB14DatabaseWriterP11GRDBCombineE14writePublisher9receiveOn7updatesAD0B10PublishersO5WriteVy_qd_0_Gqd___qd_0_AA0B0CKct7Combine9SchedulerRd__r0_lF">DatabaseWriter.writePublisher(receiveOn:updates:)</a></code></h4>

<p>This method returns a publisher that completes after database updates have been successfully executed inside a database transaction.</p>
<pre class="highlight swift"><code><span class="c1">// DatabasePublishers.Write&lt;Void&gt;</span>
<span class="k">let</span> <span class="nv">write</span> <span class="o">=</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">writePublisher</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DatabasePublishers.Write&lt;Int&gt;</span>
<span class="k">let</span> <span class="nv">newPlayerCount</span> <span class="o">=</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">writePublisher</span> <span class="p">{</span> <span class="n">db</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchCount</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>This publisher can be subscribed from any thread. A new database access starts on every subscription.</p>

<p>It completes on the main queue, unless you provide a specific <a href="https://developer.apple.com/documentation/combine/scheduler">scheduler</a> to the <code>receiveOn</code> argument.</p>

<p>When you use a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-pools">database pool</a>, and your app executes some database updates followed by some slow fetches, you may profit from optimized scheduling with <a href="#databasewriterwritepublisherreceiveonupdatesthenread"><code>writePublisher(receiveOn:updates:thenRead:)</code></a>. See below.</p>
<h4 id='code-databasewriter-writepublisher-receiveon-updates-thenread-code' class='heading'><code><a href="Extensions/DatabaseWriter.html#/s:4GRDB14DatabaseWriterP11GRDBCombineE14writePublisher9receiveOn7updates8thenReadAD0B10PublishersO5WriteVy_qd_1_Gqd___qd_0_AA0B0CKcqd_1_AO_qd_0_tKct7Combine9SchedulerRd__r1_lF">DatabaseWriter.writePublisher(receiveOn:updates:thenRead:)</a></code></h4>

<p>This method returns a publisher that completes after database updates have been successfully executed inside a database transaction, and values have been subsequently fetched:</p>
<pre class="highlight swift"><code><span class="c1">// DatabasePublishers.Write&lt;Int&gt;</span>
<span class="k">let</span> <span class="nv">newPlayerCount</span> <span class="o">=</span> <span class="n">dbQueue</span><span class="o">.</span><span class="nf">writePublisher</span><span class="p">(</span>
    <span class="nv">updates</span><span class="p">:</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span> <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="p">}</span>
    <span class="nv">thenRead</span><span class="p">:</span> <span class="p">{</span> <span class="n">db</span><span class="p">,</span> <span class="n">_</span> <span class="k">in</span> <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchCount</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre>

<p>It publishes exactly the same values as <a href="#databasewriterwritepublisherreceiveonupdates"><code>writePublisher(receiveOn:updates:)</code></a>:</p>
<pre class="highlight swift"><code><span class="c1">// DatabasePublishers.Write&lt;Int&gt;</span>
<span class="k">let</span> <span class="nv">newPlayerCount</span> <span class="o">=</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">writePublisher</span> <span class="p">{</span> <span class="n">db</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchCount</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>

<p>The difference is that the last fetches are performed in the <code>thenRead</code> function. This function accepts two arguments: a readonly database connection, and the result of the <code>updates</code> function. This allows you to pass information from a function to the other (it is ignored in the sample code above).</p>

<p>When you use a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-pools">database pool</a>, this method applies a scheduling optimization: the <code>thenRead</code> function sees the database in the state left by the <code>updates</code> function, and yet does not block any concurrent writes. This can reduce database write contention. See <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#advanced-databasepool">Advanced DatabasePool</a> for more information.</p>

<p>When you use a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-queues">database queue</a>, the results are guaranteed to be identical, but no scheduling optimization is applied.</p>

<p>This publisher can be subscribed from any thread. A new database access starts on every subscription.</p>

<p>It completes on the main queue, unless you provide a specific <a href="https://developer.apple.com/documentation/combine/scheduler">scheduler</a> to the <code>receiveOn</code> argument.</p>
<h1 id='database-observation' class='heading'>Database Observation</h1>

<p>Database Observation publishers are based on GRDB&rsquo;s <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservation">ValueObservation</a> and <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#databaseregionobservation">DatabaseRegionObservation</a>. Please refer to their documentation for more information. If your application needs change notifications that are not built in GRDBCombine, check the general <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#database-changes-observation">Database Changes Observation</a> chapter.</p>

<ul>
<li><a href="#valueobservationpublisherinscheduling"><code><a href="Extensions/ValueObservation.html#/s:4GRDB16ValueObservationV11GRDBCombineE9publisher2in10schedulingAD18DatabasePublishersO0B0Vy_AJQzGAA0H6Reader_p_AA0bC9SchedulerCtF">ValueObservation.publisher(in:scheduling:)</a></code></a></li>
<li><a href="#databaseregionobservationpublisherin"><code><a href="Extensions/DatabaseRegionObservation.html#/s:4GRDB25DatabaseRegionObservationV11GRDBCombineE9publisher2inAD0B10PublishersO0bC0VAA0B6Writer_p_tF">DatabaseRegionObservation.publisher(in:)</a></code></a></li>
</ul>
<h4 id='code-valueobservation-publisher-in-scheduling-code' class='heading'><code><a href="Extensions/ValueObservation.html#/s:4GRDB16ValueObservationV11GRDBCombineE9publisher2in10schedulingAD18DatabasePublishersO0B0Vy_AJQzGAA0H6Reader_p_AA0bC9SchedulerCtF">ValueObservation.publisher(in:scheduling:)</a></code></h4>

<p>GRDB&rsquo;s <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservation">ValueObservation</a> tracks changes in database values. You can turn it into a Combine publisher:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">observation</span> <span class="o">=</span> <span class="kt">ValueObservation</span><span class="o">.</span><span class="n">tracking</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchAll</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// A publisher with output [Player] and failure Error</span>
<span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">dbQueue</span><span class="p">)</span>
</code></pre>

<p>This publisher has the same behavior as ValueObservation:</p>

<ul>
<li>It notifies an initial value before the eventual changes.</li>
<li>It may coalesce subsequent changes into a single notification.</li>
<li>It may notify consecutive identical values. You can filter out the undesired duplicates with the <code>removeDuplicates()</code> Combine operator, but we suggest you have a look at the <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservationremoveduplicates">removeDuplicates()</a> GRDB operator also.</li>
<li>It stops emitting any value after the database connection is closed. But it never completes.</li>
<li><p>By default, it notifies the initial value, as well as eventual changes and errors, on the main thread, asynchronously.</p>

<p>This can be configured with the <code>scheduling</code> argument. It does not accept a Combine scheduler, but a <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservation-scheduling">GRDB scheduler</a>.</p>

<p>For example, the <code>.immediate</code> scheduler makes sure the initial value is notified immediately when the publisher is subscribed. It can help your application update the user interface without having to wait for any asynchronous notifications:</p>
<pre class="highlight swift"><code><span class="c1">// Immediate notification of the initial value</span>
<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="n">observation</span>
    <span class="o">.</span><span class="nf">publisher</span><span class="p">(</span>
        <span class="nv">in</span><span class="p">:</span> <span class="n">dbQueue</span><span class="p">,</span>
        <span class="nv">scheduling</span><span class="p">:</span> <span class="o">.</span><span class="n">immediate</span><span class="p">)</span> <span class="c1">// &lt;-</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span> <span class="o">...</span> <span class="p">},</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">players</span><span class="p">:</span> <span class="p">[</span><span class="kt">Player</span><span class="p">])</span> <span class="k">in</span> <span class="nf">print</span><span class="p">(</span><span class="s">"Fresh players: </span><span class="se">\(</span><span class="n">players</span><span class="se">)</span><span class="s">"</span><span class="p">)</span> <span class="p">})</span>
<span class="c1">// &lt;- here "fresh players" is already printed.</span>
</code></pre>

<p>Note that the <code>.immediate</code> scheduler requires that the publisher is subscribed from the main thread. It raises a fatal error otherwise.</p></li>
</ul>

<p>See <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservation-scheduling">ValueObservation Scheduling</a> for more information.</p>

<p>:warning: <strong>ValueObservation and Data Consistency</strong></p>

<p>When you compose ValueObservation publishers together with the <a href="https://developer.apple.com/documentation/combine/publisher/3333677-combinelatest">combineLatest</a> operator, you lose all guarantees of <a href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">data consistency</a>.</p>

<p>Instead, compose requests together into <strong>one single</strong> ValueObservation, as below (this is the technique used in the <a href="Documentation/Demo/README.md">Demo Application</a>):</p>
<pre class="highlight swift"><code><span class="c1">// DATA CONSISTENCY GUARANTEED</span>
<span class="k">let</span> <span class="nv">hallOfFamePublisher</span> <span class="o">=</span> <span class="kt">ValueObservation</span>
    <span class="o">.</span><span class="n">tracking</span> <span class="p">{</span> <span class="n">db</span> <span class="o">-&gt;</span> <span class="kt">HallOfFame</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">playerCount</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">fetchCount</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">bestPlayers</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="nf">orderedByScore</span><span class="p">()</span><span class="o">.</span><span class="nf">fetchAll</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
        <span class="k">return</span> <span class="kt">HallOfFame</span><span class="p">(</span><span class="nv">playerCount</span><span class="p">:</span><span class="n">playerCount</span><span class="p">,</span> <span class="nv">bestPlayers</span><span class="p">:</span><span class="n">bestPlayers</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">dbQueue</span><span class="p">)</span>
</code></pre>

<p>See <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#valueobservation">ValueObservation</a> for more information.</p>
<h4 id='code-databaseregionobservation-publisher-in-code' class='heading'><code><a href="Extensions/DatabaseRegionObservation.html#/s:4GRDB25DatabaseRegionObservationV11GRDBCombineE9publisher2inAD0B10PublishersO0bC0VAA0B6Writer_p_tF">DatabaseRegionObservation.publisher(in:)</a></code></h4>

<p>GRDB&rsquo;s <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#databaseregionobservation">DatabaseRegionObservation</a> notifies all transactions that impact a tracked database region. You can turn it into a Combine publisher:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">all</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">observation</span> <span class="o">=</span> <span class="kt">DatabaseRegionObservation</span><span class="o">.</span><span class="nf">tracking</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

<span class="c1">// A publisher with output Database and failure Error</span>
<span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="n">observation</span><span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">dbQueue</span><span class="p">)</span>
</code></pre>

<p>This publisher can be created and subscribed from any thread. It delivers database connections in a &quot;protected dispatch queue&rdquo;, serialized with all database updates. It only completes when a database error happens.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">request</span> <span class="o">=</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">all</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">cancellable</span> <span class="o">=</span> <span class="kt">DatabaseRegionObservation</span>
    <span class="o">.</span><span class="nf">tracking</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">publisher</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">dbQueue</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">sink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span> <span class="o">...</span> <span class="p">},</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nv">db</span><span class="p">:</span> <span class="kt">Database</span><span class="p">)</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Players have changed."</span><span class="p">)</span>
        <span class="p">})</span>

<span class="k">try</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">write</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Arthur"</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Barbara"</span><span class="p">)</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span> 
<span class="c1">// Prints "Players have changed."</span>

<span class="k">try</span> <span class="n">dbQueue</span><span class="o">.</span><span class="n">write</span> <span class="p">{</span> <span class="n">db</span> <span class="k">in</span>
    <span class="k">try</span> <span class="kt">Player</span><span class="o">.</span><span class="nf">deleteAll</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Prints "Players have changed."</span>
</code></pre>

<p>See <a href="https://github.com/groue/GRDB.swift/blob/master/README.md#databaseregionobservation">DatabaseRegionObservation</a> for more information.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2020 <a class="link" href="https://github.com/groue" target="_blank" rel="external">Gwendal Roué</a>. All rights reserved. (Last updated: 2020-06-26)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.13.4</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
